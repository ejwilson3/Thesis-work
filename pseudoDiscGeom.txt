discretize_geom (mesh mesh, int num_rays = 10, boolean grid = false) {
    if mesh is unordered
        //fix somehow? not actually sure what this means.

    else {
        meshPartition part(mesh, num_rays, grid)
        int d3

  // I don't actually know what type these will be. Vectors of doubles, probably.
        div[3] divs

        vector<double[2]> sums

        for (int i = 0, i < 3, i++) {
            divs[i] = mesh.get divisions (i)
        }

/*
* Parallelization idea: Single for loop with dimensions and depth into directions 
* determined by something like "if i < divs[0].length() d = d0...".
* I think this might be faster with more processors as they could divide the
* mesh more evenly, but you'd have to figure out "part" entirely each time. 
* Might need to do that anyways with parallelization, though, and it makes
* it even less human readable.
*/

        for (int d1 = 0, d1 < 3, d1++) {
            for (int i = 0, i < divs[d1].length(), i++) {
                int d2
                if (d1 = 2)
                    d2 = 0
                else
                    d2 = d1 + 1
                d3 = 3 - d1 - d2

                part.setDimension1(divs[d1][i], divs[d1][i+1]) 
                for (int j = 0, j < divs[d2].length(), j++) {
                    part.setDimension2(divs[d2][j], divs[d2][j+1])
                    part.fireRays(d3, divs[d3])
                    sums.append(part.getSums())
                }
            }
        }
    }
}

class MeshPartition {

    mesh mesh
    int num_rays
    boolean grid
    vector<double[2]> sums
    double start_point_x
    double start_point_y

    //I think these will be doubles, but I'm not sure.
    div_p d1div1
    div_p d1div2
    div_p d2div1
    div_p d2div2
    div_p[] d3divs

public:
    MeshPartition (mesh mesh, int num_rays, boolean grid){
        if (grid && sqrt(num_rays**2) != num_rays) {
            throw new exception
        }
        this.mesh = mesh
        this.num_rays = num_rays
        this.grid = grid
        sums.at(0)[0] = 0
        sums.at(0)[1] = 0
        d1div1 = NULL
        d1div2 = NULL
        d2div1 = NULL
        d2div2 = NULL
    }

    ~MeshPartition () {}

    void setDimension1(div_p div1, div_p div2) {
        d1div1 = div1
        d1div2 = div2
    }

    void setDimension2(div_p div1, div_p div2) {
        d2div1 = div1
        d2div2 = div2
    }

    void fireRays(int d3, div_p[] divs) {
        d3divs = divs
        vol vol
        for (int i = 0, i < d3divs.length() - 1) {
           //It's got to be double, right? If you can subtract it to make width?
            double[] width = d3divs[i+1] - d3divs[i]
        }

/* 
* This will likely have to change for the parallel version, unless we want
* to just parallelize the individual ray fires, rather than the whole process.
* Somehow for a grid, you need to be able to find your starting point from 
* your number. This is important since I want to be able to separate each ray
* fire between nodes, not each row of divisions.
* Maybe loop over all of them in the big loop, rather than as part of the 
* class?  That will make it even less readable...
*/

        for (int i = 0, i < num_rays, i++){
            startPoints(i)
            //TODO - Figure this out
            if (!point_in_volume(vol, point, direction) {
                vol = find_volume(use start points and d3)
            }
            double value
            //Something that gives next volume id, distance to next volume, and 
            //surface id. Don't actually need surface id for this one.
            //takes current volume, point, and direction.
            ray_iterator?
            //TODO
            if {
                dag_ray_follow(vol, 
            }
            for (i = 0, i < width.length(), i++) {
                do {
                    if (distance >= width[i]) {
                        value = 1
                        distance -= width[i]
                    }
                    else {
                        value = distance/width[i]
                    }
                    double[2] sample
                    sample[0] = value
                    sample[1] = value**2
                    sums.append(sample)
                } while ()
            }
        }
    }

    double[2] getSums() {
    //I either need to change this or change how I use it.  Perhaps a struct would be good, to hold the two sums and some id of the cell and direction.
        return sums
    }

private:
    void startPoints(int iter) {
        double dist_x = d1div2 - d1div1
        double dist_y = d2div2 - d2div1
        if (grid) {
            int points = sqrt(num_rays)
            //These essentially make the for loop into two nested for loops.
            //This will iterate from 1 to points, and repeat points times.
            int iter_x = iter%points + 1
            //This will iterate the same range, but more slowly.
            int iter_y = iter/points + 1

            start_point_x = d1div1 + dist_x/(points + 1)*iter_x
            start_point_y = d2div1 + dist_y/(points + 1)*iter_y
        }
        else {
            start_point_x = d1div1 + dist_x*rand
            start_point_y = d2div1 + dist_y*rand
        }
    }
}
